import streamlit as st
import pandas as pd
import openpyxl
from openpyxl import load_workbook
import re
from datetime import datetime, timedelta
import io
from typing import List, Dict, Any

# Page configuration
st.set_page_config(
    page_title="„Çπ„Ç±„Ç∏„É•„Éº„É´Â§âÊèõ„ÉÑ„Éº„É´",
    page_icon="üìÖ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for better styling
st.markdown("""
<style>
    .main-header {
        font-size: 3rem;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        text-align: center;
        margin-bottom: 2rem;
    }
    .step-container {
        border: 2px solid #667eea;
        border-radius: 10px;
        padding: 1rem;
        margin: 1rem 0;
        background-color: #f8f9fa;
    }
    .success-box {
        background-color: #d4edda;
        border: 1px solid #c3e6cb;
        border-radius: 5px;
        padding: 1rem;
        margin: 1rem 0;
    }
    .error-box {
        background-color: #f8d7da;
        border: 1px solid #f5c6cb;
        border-radius: 5px;
        padding: 1rem;
        margin: 1rem 0;
    }
    .info-box {
        background-color: #d1ecf1;
        border: 1px solid #bee5eb;
        border-radius: 5px;
        padding: 1rem;
        margin: 1rem 0;
    }
</style>
""", unsafe_allow_html=True)

class ScheduleConverter:
    def __init__(self):
        self.parsed_schedule = []
        
    def parse_schedule_text(self, text: str) -> List[Dict[str, Any]]:
        """Parse Japanese schedule text format"""
        lines = [line.strip() for line in text.split('\n') if line.strip()]
        schedule = []
        
        # Extract year and month from date range
        year_month_match = re.search(r'(\d{4})Âπ¥(\d{1,2})Êúà', lines[0])
        year = int(year_month_match.group(1)) if year_month_match else datetime.now().year
        month = int(year_month_match.group(2)) if year_month_match else datetime.now().month
        
        current_date = None
        current_full_date = None
        i = 0
        
        # Find where the actual schedule data starts
        while i < len(lines):
            line = lines[i]
            date_match = re.match(r'^(\d{1,2})\([Êó•ÊúàÁÅ´Ê∞¥Êú®ÈáëÂúü]\)$', line)
            if date_match:
                break
            i += 1
        
        while i < len(lines):
            line = lines[i]
            
            # Check for date line (format: "23(Êúà)")
            date_match = re.match(r'^(\d{1,2})\([Êó•ÊúàÁÅ´Ê∞¥Êú®ÈáëÂúü]\)$', line)
            if date_match:
                current_date = line
                day_num = int(date_match.group(1))
                current_full_date = datetime(year, month, day_num)
                i += 1
                continue
            
            # Check for content in English parentheses (no time/location)
            if current_full_date and line.startswith('(') and line.endswith(')'):
                activity_text = line[1:-1].strip()
                schedule.append({
                    'date': current_date,
                    'full_date': current_full_date,
                    'time': '',
                    'location': '',
                    'activity': activity_text,
                    'has_all_data': False
                })
                i += 1
                continue
            
            # Check for time and activity line (format: "08:50 Â∑ùÂè£Êú¨ÈÉ®")
            time_activity_match = re.match(r'^(\d{1,2}):(\d{2})\s+(.+)$', line)
            if time_activity_match and current_full_date:
                time = f"{time_activity_match.group(1)}:{time_activity_match.group(2)}"
                activity_text = time_activity_match.group(3).strip()
                
                # Parse location and activity
                location = ''
                activity = ''
                
                if '(' in activity_text and ')' in activity_text:
                    # Text in parentheses is activity
                    activity = re.sub(r'[()]', '', activity_text)
                    location = ''
                elif activity_text == 'Á§æÁî®ËªäÂ∏∞ÂÆÖ':
                    location = 'Á§æÁî®ËªäÂ∏∞ÂÆÖ'
                    activity = ''
                else:
                    # Split by space
                    parts = re.split(r'[„ÄÄ\s]+', activity_text)
                    location = parts[0] if parts else ''
                    activity = ' '.join(parts[1:]) if len(parts) > 1 else ''
                
                # Handle special case
                if not activity and location:
                    if any(keyword in location for keyword in ['ÊâìÂêà„Åõ', '‰ºöË≠∞', 'Ë¶ãÂ≠¶', 'ÂèÇÂä†', 'È£ü‰∫ã', 'ÊâãÈÖç', 'ÂØæÂøú']):
                        activity = location
                        location = ''
                
                # Determine if this entry has all data
                has_all_data = bool(time and (location or activity))
                
                schedule.append({
                    'date': current_date,
                    'full_date': current_full_date,
                    'time': time,
                    'location': location,
                    'activity': activity,
                    'has_all_data': has_all_data
                })
            
            i += 1
        
        return schedule
    
    def generate_filename(self, text: str) -> str:
        """Generate filename from schedule date range"""
        date_range_match = re.search(
            r'(\d{4})Âπ¥(\d{1,2})Êúà(\d{1,2})Êó•\([Êó•ÊúàÁÅ´Ê∞¥Êú®ÈáëÂúü]\)\s*ÔΩû\s*(\d{4})Âπ¥(\d{1,2})Êúà(\d{1,2})Êó•\([Êó•ÊúàÁÅ´Ê∞¥Êú®ÈáëÂúü]\)',
            text
        )
        
        if date_range_match:
            start_year = date_range_match.group(1)
            start_month = date_range_match.group(2).zfill(2)
            start_day = date_range_match.group(3).zfill(2)
            end_year = date_range_match.group(4)
            end_month = date_range_match.group(5).zfill(2)
            end_day = date_range_match.group(6).zfill(2)
            
            return f"{start_year}{start_month}{start_day}to{end_year}{end_month}{end_day}.xlsx"
        
        return f"weekly_schedule_{datetime.now().strftime('%Y%m%d')}.xlsx"
    
    def create_excel_file(self, template_file, schedule_data: List[Dict]) -> bytes:
        """Create Excel file with schedule data"""
        wb = load_workbook(template_file)
        ws = wb.active
        
        if not schedule_data:
            excel_buffer = io.BytesIO()
            wb.save(excel_buffer)
            excel_buffer.seek(0)
            return excel_buffer.getvalue()
        
        # Extract start date from first entry
        first_entry = min(schedule_data, key=lambda x: x['full_date'])
        start_date = first_entry['full_date']
        
        # Generate all 7 days of the week
        all_dates = []
        for i in range(7):
            date = start_date + timedelta(days=i)
            all_dates.append(date)
        
        # Group schedule by date
        schedule_by_date = {}
        for item in schedule_data:
            date_key = item['full_date'].strftime('%Y-%m-%d')
            if date_key not in schedule_by_date:
                schedule_by_date[date_key] = []
            schedule_by_date[date_key].append(item)
        
        # Sort entries: complete entries first
        for date_key in schedule_by_date:
            schedule_by_date[date_key].sort(key=lambda x: (not x.get('has_all_data', True), x['time'] or '99:99'))
        
        # Japanese day names
        day_names = ['Êúà', 'ÁÅ´', 'Ê∞¥', 'Êú®', 'Èáë', 'Âúü', 'Êó•']
        
        # Populate Excel sheet
        for day_idx, date in enumerate(all_dates):
            date_key = date.strftime('%Y-%m-%d')
            day_entries = schedule_by_date.get(date_key, [])
            
            # Calculate starting row (6-row blocks)
            day_start_row = 7 + (day_idx * 6)
            
            # Get day of week
            weekday_idx = date.weekday()
            day_name = day_names[weekday_idx]
            
            # Format the date column
            for row_offset in range(6):
                current_row = day_start_row + row_offset
                
                if row_offset == 0:
                    # First row: Day name in parentheses
                    ws.cell(row=current_row, column=1, value=f"({day_name})")
                elif row_offset == 1:
                    # Second row: Full date
                    ws.cell(row=current_row, column=1, value=date.strftime('%Y/%m/%d'))
                else:
                    # Rows 3-6: Leave blank
                    ws.cell(row=current_row, column=1, value="")
            
            # Process entries for this day
            row_index = day_start_row
            for entry in day_entries:
                # Set time
                if entry['time']:
                    time_parts = entry['time'].split(':')
                    time_value = datetime(1899, 12, 30, int(time_parts[0]), int(time_parts[1]))
                    ws.cell(row=row_index, column=2, value=time_value)
                else:
                    ws.cell(row=row_index, column=2, value="")
                
                # Set location (remove parentheses)
                location_clean = re.sub(r'[()]', '', entry['location']) if entry['location'] else ''
                ws.cell(row=row_index, column=3, value=location_clean)
                
                # Set activity (remove parentheses)
                activity_clean = re.sub(r'[()]', '', entry['activity']) if entry['activity'] else ''
                ws.cell(row=row_index, column=4, value=activity_clean)
                
                row_index += 1
                
                # Don't exceed the 6-row block
                if row_index >= day_start_row + 6:
                    break
        
        # Save to bytes
        excel_buffer = io.BytesIO()
        wb.save(excel_buffer)
        excel_buffer.seek(0)
        return excel_buffer.getvalue()

def main():
    st.markdown('<h1 class="main-header">üìÖ „Çπ„Ç±„Ç∏„É•„Éº„É´Â§âÊèõ„ÉÑ„Éº„É´</h1>', unsafe_allow_html=True)
    
    # Initialize converter
    converter = ScheduleConverter()
    
    # Sidebar
    with st.sidebar:
        st.markdown("## üìã ‰ΩøÁî®ÊñπÊ≥ï")
        st.markdown("""
        1. **Excel„ÉÜ„É≥„Éó„É¨„Éº„Éà„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ**
        2. **„Çπ„Ç±„Ç∏„É•„Éº„É´„ÉÜ„Ç≠„Çπ„Éà„ÇíË≤º„Çä‰ªò„Åë**
        3. **Ëß£Êûê„Å®„Éó„É¨„Éì„É•„Éº**
        4. **Excel„Éï„Ç°„Ç§„É´„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ**
        """)
        
        st.markdown("## üîß Ê©üËÉΩ")
        st.markdown("""
        - ‚úÖ Êó•Êú¨Ë™û„ÉÜ„Ç≠„Çπ„Éà„ÅÆËß£Êûê
        - ‚úÖ Excel„Éï„Ç©„Éº„Éû„ÉÉ„Éà„ÅÆ‰øùÊåÅ
        - ‚úÖ 6Ë°å„Éñ„É≠„ÉÉ„ÇØÊßãÈÄ†
        - ‚úÖ Ëã±Ë™ûÊã¨ÂºßÂØæÂøú `(ÂÜÖÂÆπ)`
        - ‚úÖ ÂÆåÂÖ®„Éá„Éº„Çø„ÅÆÂÑ™ÂÖàË°®Á§∫
        """)
    
    # Main content
    col1, col2 = st.columns([1, 1])
    
    with col1:
        st.markdown('<div class="step-container">', unsafe_allow_html=True)
        st.markdown("### üìÑ „Çπ„ÉÜ„ÉÉ„Éó1: Excel„ÉÜ„É≥„Éó„É¨„Éº„Éà")
        
        excel_template = st.file_uploader(
            "Excel„ÉÜ„É≥„Éó„É¨„Éº„Éà„Éï„Ç°„Ç§„É´ (.xlsx) „ÇíÈÅ∏Êäû",
            type=['xlsx']
        )
        
        if excel_template:
            st.markdown('<div class="success-box">‚úÖ „ÉÜ„É≥„Éó„É¨„Éº„ÉàË™≠„ÅøËæº„ÅøÂÆå‰∫Ü</div>', unsafe_allow_html=True)
        
        st.markdown('</div>', unsafe_allow_html=True)
        
        st.markdown('<div class="step-container">', unsafe_allow_html=True)
        st.markdown("### üì± „Çπ„ÉÜ„ÉÉ„Éó2: „Çπ„Ç±„Ç∏„É•„Éº„É´„Éá„Éº„Çø")
        
        sample_text = """„Åì„Åì„Å´„ÉÜ„Ç≠„Çπ„Éà„ÇíË≤º„Çä‰ªò„Åë„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"""
        
        schedule_text = st.text_area(
            "„Çπ„Ç±„Ç∏„É•„Éº„É´„ÉÜ„Ç≠„Çπ„Éà„ÇíË≤º„Çä‰ªò„Åë:",
            value=sample_text,
            height=400
        )
        
        st.markdown('</div>', unsafe_allow_html=True)
    
    with col2:
        st.markdown('<div class="step-container">', unsafe_allow_html=True)
        st.markdown("### üîç „Çπ„ÉÜ„ÉÉ„Éó3: Ëß£Êûê„Å®„Éó„É¨„Éì„É•„Éº")
        
        if st.button("üîç „Çπ„Ç±„Ç∏„É•„Éº„É´„ÇíËß£Êûê", type="primary"):
            if schedule_text.strip():
                try:
                    converter.parsed_schedule = converter.parse_schedule_text(schedule_text)
                    st.session_state.parsed_schedule = converter.parsed_schedule
                    st.session_state.schedule_text = schedule_text
                    
                    complete_entries = sum(1 for item in converter.parsed_schedule if item.get('has_all_data', True))
                    incomplete_entries = len(converter.parsed_schedule) - complete_entries
                    
                    st.markdown(f'<div class="success-box">‚úÖ {len(converter.parsed_schedule)}‰ª∂„ÇíËß£ÊûêÂÆå‰∫ÜÔºÅ<br/>ÂÆåÂÖ®„Éá„Éº„Çø: {complete_entries}‰ª∂ | ÈÉ®ÂàÜ„Éá„Éº„Çø: {incomplete_entries}‰ª∂</div>', unsafe_allow_html=True)
                except Exception as e:
                    st.markdown(f'<div class="error-box">‚ùå „Ç®„É©„Éº: {str(e)}</div>', unsafe_allow_html=True)
            else:
                st.markdown('<div class="error-box">‚ùå „ÉÜ„Ç≠„Çπ„Éà„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ</div>', unsafe_allow_html=True)
        
        # Display preview
        if hasattr(st.session_state, 'parsed_schedule') and st.session_state.parsed_schedule:
            st.markdown("#### üìã „Éó„É¨„Éì„É•„Éº:")
            
            preview_data = []
            for item in st.session_state.parsed_schedule:
                priority = "üî¥ ÂÆåÂÖ®" if item.get('has_all_data', True) else "üü° ÈÉ®ÂàÜ"
                location_clean = re.sub(r'[()]', '', item['location']) if item['location'] else '-'
                activity_clean = re.sub(r'[()]', '', item['activity']) if item['activity'] else '-'
                
                preview_data.append({
                    'ÊúàÊó•': item['full_date'].strftime('%m/%d (%a)'),
                    'ÂÑ™ÂÖàÂ∫¶': priority,
                    'AM/PM': item['time'] or '-',
                    'Ë®™ÂïèÂÖà': location_clean,
                    'Èù¢Ë´áÂÜÖÂÆπ': activity_clean
                })
            
            df = pd.DataFrame(preview_data)
            st.dataframe(df, use_container_width=True)
        
        st.markdown('</div>', unsafe_allow_html=True)
    
    # Generate Excel
    st.markdown('<div class="step-container">', unsafe_allow_html=True)
    st.markdown("### üìä „Çπ„ÉÜ„ÉÉ„Éó4: Excel„Éï„Ç°„Ç§„É´ÁîüÊàê")
    
    col3, col4 = st.columns([1, 1])
    
    with col3:
        if st.button("üìä Excel„Éï„Ç°„Ç§„É´„ÇíÁîüÊàê", type="primary", use_container_width=True):
            if not excel_template:
                st.error("Excel„ÉÜ„É≥„Éó„É¨„Éº„Éà„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
            elif not hasattr(st.session_state, 'parsed_schedule') or not st.session_state.parsed_schedule:
                st.error("ÂÖà„Å´„Çπ„Ç±„Ç∏„É•„Éº„É´„ÇíËß£Êûê„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
            else:
                try:
                    excel_data = converter.create_excel_file(excel_template, st.session_state.parsed_schedule)
                    filename = converter.generate_filename(st.session_state.schedule_text)
                    
                    st.download_button(
                        label="üíæ Excel„Éï„Ç°„Ç§„É´„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ",
                        data=excel_data,
                        file_name=filename,
                        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                        use_container_width=True
                    )
                    
                    st.success(f"‚úÖ '{filename}' ÁîüÊàêÂÆå‰∫ÜÔºÅ")
                    
                except Exception as e:
                    st.error(f"‚ùå „Ç®„É©„Éº: {str(e)}")
    
    with col4:
        st.markdown('<div class="info-box">', unsafe_allow_html=True)
        st.markdown("**üí° ÂØæÂøúÂΩ¢Âºè:**")
        st.markdown("""
        - **ÂÆåÂÖ®‰∫àÂÆö**: `08:50 Â∑ùÂè£Êú¨ÈÉ®`
        - **Ê¥ªÂãï„ÅÆ„Åø**: `(Ê¢±ÂåÖË≥áÊùêË≥ºÂÖ•)`
        - **Êã¨ÂºßÂÜÖÂÆπ**: `15:00 (VE‰ºöË≠∞)`
        """)
        st.markdown('</div>', unsafe_allow_html=True)
    
    st.markdown('</div>', unsafe_allow_html=True)

if __name__ == "__main__":
    main()